# WebSocket Client - Gi·∫£i Th√≠ch Chi Ti·∫øt

## üéØ T√≥m T·∫Øt

**WebSocket Client** l√† ph·∫ßn code ch·∫°y ·ªü **ph√≠a browser** (client-side) ƒë·ªÉ k·∫øt n·ªëi real-time v·ªõi WebSocket Server.

Trong project n√†y c√≥ **2 lo·∫°i WebSocket client**:

---

## üìÇ 1. JavaScript WebSocket Client (Production)

### üìç Location
```
client/scripts/websocket/
‚îú‚îÄ‚îÄ client.js      ‚Üê WebSocket Manager (k·∫øt n·ªëi, g·ª≠i, nh·∫≠n message)
‚îî‚îÄ‚îÄ protocol.js    ‚Üê Message protocol (build/parse messages)
```

### üîß Ch·ª©c nƒÉng

#### A. `client/scripts/websocket/client.js`
**WebSocket connection manager cho browser**

```javascript
class WebSocketManager {
    connect(roomId, playerId) {
        // T·∫°o k·∫øt n·ªëi WebSocket
        const wsUrl = `ws://localhost:9160?roomId=${roomId}&playerId=${playerId}`;
        this.ws = new WebSocket(wsUrl);
        
        this.ws.onopen = () => {
            console.log('WebSocket connected');
        };
        
        this.ws.onmessage = (event) => {
            this.handleMessage(event.data);
        };
        
        this.ws.onclose = () => {
            console.log('WebSocket closed');
        };
    }
    
    send(message) {
        this.ws.send(message);
    }
    
    on(messageType, callback) {
        this.messageHandlers[messageType] = callback;
    }
}
```

**ƒê√¢y l√† WebSocket client th·∫≠t s·ª± d√πng trong game!**

#### B. `client/scripts/websocket/protocol.js`
**Message protocol helpers**

```javascript
const Protocol = {
    // Build message to send
    buildReadyMessage(playerId, fleet) {
        return JSON.stringify({
            type: 'ready',
            rmPlayerId: playerId,
            rmFleet: fleet
        });
    },
    
    buildAttackMessage(playerId, position) {
        return JSON.stringify({
            type: 'attack',
            amPlayerId: playerId,
            amPosition: position
        });
    },
    
    // Parse message received
    parseMessage(data) {
        return JSON.parse(data);
    }
};
```

### üìñ C√°ch S·ª≠ D·ª•ng Trong Game

**File:** `client/pages/1v1/room.html` ho·∫∑c game pages

```javascript
// 1. Import
import WSManager from '/scripts/websocket/client.js';
import Protocol from '/scripts/websocket/protocol.js';

// 2. Connect
await WSManager.connect(roomId, playerId);

// 3. Register handlers
WSManager.on('attack_result', (message) => {
    console.log('Attack result:', message);
    // Update UI...
});

WSManager.on('game_over', (message) => {
    console.log('Game over:', message);
    // Show winner...
});

// 4. Send messages
// Ready
const readyMsg = Protocol.buildReadyMessage(playerId, fleet);
WSManager.send(readyMsg);

// Attack
const attackMsg = Protocol.buildAttackMessage(playerId, position);
WSManager.send(attackMsg);
```

---

## üß™ 2. Haskell WebSocket Client (Test Only)

### üìç Location
```
test/Spec.hs      ‚Üê WebSocket test client
```

### üîß Ch·ª©c nƒÉng

**Haskell WebSocket client CH·ªà d√πng trong test suite**

```haskell
-- H√†m connect WebSocket t·ª´ test
connectClient :: String -> String -> IO WS.Connection
connectClient roomId playerId = do
    let url = wsUrl roomId playerId
    WS.runClient testHost testPort 
        ("/?roomId=" ++ roomId ++ "&playerId=" ++ playerId) 
        return
```

**ƒê√¢y l√† client gi·∫£ l·∫≠p ƒë·ªÉ test server!**

#### V√≠ d·ª• test:

```haskell
it "should accept valid WebSocket connection" $ do
    state <- startTestServer  -- Start server
    
    result <- (do
        -- T·∫°o WebSocket connection (Haskell client)
        conn <- connectClient "ROOM01" "PLAY01"
        
        -- Send message
        WS.sendTextData conn (encode someMessage)
        
        -- Close
        WS.sendClose conn ("Done" :: T.Text)
        return True
    ) `catch` (\(_ :: SomeException) -> return False)
    
    result `shouldBe` True
```

---

## üîÑ Flow Diagram - Client vs Server

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    WEBSOCKET ARCHITECTURE                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

PRODUCTION (Real Game):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Browser (Client-side)  ‚îÇ         ‚îÇ   Haskell (Server-side)  ‚îÇ
‚îÇ                          ‚îÇ         ‚îÇ                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ         ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ client.js          ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ WebSocket.Server   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ new WebSocket()    ‚îÇ‚óÑ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚ñ∫‚îÇ WS.ServerApp       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                    ‚îÇ  ‚îÇ ws://   ‚îÇ  ‚îÇ                    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ws.send(msg)       ‚îÇ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  ‚îÇ receiveData        ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ws.onmessage       ‚îÇ‚óÑ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îÇ sendTextData       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                    ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ                    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ         ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                          ‚îÇ         ‚îÇ                          ‚îÇ
‚îÇ  client/scripts/         ‚îÇ         ‚îÇ  src/Network/            ‚îÇ
‚îÇ  websocket/client.js     ‚îÇ         ‚îÇ  WebSocket/Server.hs     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

TEST (Automated Testing):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Haskell Test Suite     ‚îÇ         ‚îÇ   Haskell (Server-side)  ‚îÇ
‚îÇ                          ‚îÇ         ‚îÇ                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ         ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ test/Spec.hs       ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ WebSocket.Server   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ WS.runClient       ‚îÇ‚óÑ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚ñ∫‚îÇ WS.ServerApp       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                    ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ                    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ WS.sendTextData    ‚îÇ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  ‚îÇ receiveData        ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ WS.receiveData     ‚îÇ‚óÑ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îÇ sendTextData       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                    ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ                    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ         ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                          ‚îÇ         ‚îÇ                          ‚îÇ
‚îÇ  Network.WebSockets lib  ‚îÇ         ‚îÇ  src/Network/            ‚îÇ
‚îÇ  (Haskell package)       ‚îÇ         ‚îÇ  WebSocket/Server.hs     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üéØ ƒêi·ªÉm Kh√°c Bi·ªát

| Aspect | JavaScript Client (Production) | Haskell Client (Test) |
|--------|--------------------------------|----------------------|
| **Location** | `client/scripts/websocket/` | `test/Spec.hs` |
| **Purpose** | Real game connections | Automated testing |
| **Runtime** | Browser (Chrome/Firefox) | Test suite (GHC) |
| **API** | Browser WebSocket API | Network.WebSockets library |
| **Usage** | User plays game | CI/CD automated tests |
| **Connection** | `new WebSocket()` | `WS.runClient` |
| **Lifecycle** | Long-lived (game session) | Short-lived (test case) |

---

## üêõ Test Failures - Root Cause

**Khi test fails:**

```
8) WebSocket Server Tests, Connection Management, should accept valid WebSocket connection
   expected: True
    but got: False
```

**Nguy√™n nh√¢n:**

1. **Haskell WebSocket client** (trong test) kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c
2. **KH√îNG PH·∫¢I** JavaScript client (production code v·∫´n works fine)

**V·∫•n ƒë·ªÅ c√≥ th·ªÉ l√†:**

```haskell
-- test/Spec.hs line ~76
connectClient :: String -> String -> IO WS.Connection
connectClient roomId playerId = do
    let url = wsUrl roomId playerId
    -- ‚ùå C√≥ th·ªÉ:
    -- - Server ch∆∞a s·∫µn s√†ng (timing issue)
    -- - Port conflicts
    -- - Path/query string sai format
    -- - Handshake failed
    WS.runClient testHost testPort 
        ("/?roomId=" ++ roomId ++ "&playerId=" ++ playerId) 
        return
```

---

## ‚úÖ Solution - Debug Test Client

**C·∫ßn fix test client (kh√¥ng ph·∫£i production client):**

```haskell
-- test/Spec.hs
connectClient :: String -> String -> IO WS.Connection
connectClient roomId playerId = do
    -- Add retry logic
    -- Add better error handling
    -- Add logging
    -- Wait for server ready
    threadDelay 1000000  -- Wait 1s for server
    
    WS.runClient testHost testPort path $ \conn -> do
        putStrLn $ "‚úì Connected: " ++ roomId ++ "/" ++ playerId
        return conn
  where
    path = "/?roomId=" ++ roomId ++ "&playerId=" ++ playerId
```

---

## üìù Summary

**WebSocket Client c√≥ 2 lo·∫°i:**

1. **JavaScript Client** (`client/scripts/websocket/client.js`)
   - ‚úÖ Production code
   - ‚úÖ Ch·∫°y trong browser
   - ‚úÖ User th·∫≠t s·ª≠ d·ª•ng
   - ‚úÖ Code n√†y works fine (kh√¥ng c√≥ v·∫•n ƒë·ªÅ)

2. **Haskell Test Client** (`test/Spec.hs`)
   - ‚ö†Ô∏è Test code only
   - ‚ö†Ô∏è Ch·∫°y trong test suite
   - ‚ö†Ô∏è Automated testing
   - ‚ùå **ƒê√ÇY L√Ä PH·∫¶N B·ªä L·ªñI** - kh√¥ng connect ƒë∆∞·ª£c

**Test failures KH√îNG ·∫£nh h∆∞·ªüng production!**

JavaScript WebSocket client v·∫´n ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng khi user ch∆°i game. Test failures ch·ªâ l√† v·∫•n ƒë·ªÅ c·ªßa test infrastructure.
